From 3956165c1ef1eb6a9a83e81616339afe36dda0d2 Mon Sep 17 00:00:00 2001
From: caleb crome <caleb@crome.org>
Date: Thu, 9 Dec 2021 13:23:19 -0800
Subject: [PATCH] Multichannel USB audio play and record

Update USB descriptors to have variable number of channels on TX and RX

Added support for defining multiple data pins.  This allows use of more than one TX and/or RX pin.

Allow for choosing different USB sample rates
---
 teensy4/AudioRate.h   | 162 +++++++++++++++
 teensy4/AudioStream.h |   6 +-
 teensy4/imxrt.h       |  10 +
 teensy4/usb_audio.cpp | 464 ++++++++++++++++++++++++------------------
 teensy4/usb_audio.h   |  19 +-
 teensy4/usb_desc.c    |  43 ++--
 teensy4/usb_desc.h    |   9 +-
 7 files changed, 473 insertions(+), 240 deletions(-)
 create mode 100644 teensy4/AudioRate.h

diff --git a/teensy4/AudioRate.h b/teensy4/AudioRate.h
new file mode 100644
index 000000000..483fdf7af
--- /dev/null
+++ b/teensy4/AudioRate.h
@@ -0,0 +1,162 @@
+/* Teensyduino Core Library
+ * http://www.pjrc.com/teensy/
+ * Copyright (c) 2017 PJRC.COM, LLC.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * "Software"), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ *
+ * 1. The above copyright notice and this permission notice shall be
+ * included in all copies or substantial portions of the Software.
+ *
+ * 2. If the Software is incorporated into a build system that allows
+ * selection among a list of target devices, then similar target
+ * devices manufactured by PJRC.COM must be included in the list of
+ * target devices and selectable in the same manner.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#ifndef AudioRate_h
+#define AudioRate_h
+
+#ifndef AUDIO_SAMPLE_RATE
+#define AUDIO_SAMPLE_RATE (44100)
+#endif
+
+#ifdef AUDIO_SAMPLE_RATE_EXACT
+#error You must set AUDIO_SAMPLE_RATE to an integer, not AUDIO_SAMPLE_RATE_EXACT to a float.  This is a change due to preprocess #if rate== stuff.  Probably can be worked around, but this is expedient.
+#endif
+
+#define AUDIO_SAMPLE_RATE_EXACT (AUDIO_SAMPLE_RATE * 1.0f)
+
+#ifndef USB_AUDIO_TX_CHANNELS
+#define USB_AUDIO_TX_CHANNELS (2U) /* NUMBER OF CHANNELS IN ISO_IN transactions */
+#endif
+
+#ifndef USB_AUDIO_RX_CHANNELS
+#define USB_AUDIO_RX_CHANNELS (2U) /* NUMBER OF CHANNELS IN ISO_OUT transactions */
+#endif
+
+#ifndef USB_AUDIO_BYTES_PER_SAMPLE
+#define USB_AUDIO_BYTES_PER_SAMPLE 2
+#endif
+
+// The number of RX data pins used for SAI reception.  
+// SAI1 on teensy 4 has 4 possible pins for each of TX/RX
+// They are shared, and can't be used simultaneously.
+// On Teensy They are
+
+// pin#  | TEENSY  | USE     | PAD
+//       | NAME    |         |
+//-------|---------|---------|---------- 
+//  7    | OUT1A   | TX1     | GPIO_B1_01_ALT3
+// 32    | OUT1B   | TX2 RX4 | GPIO_B0_12_ALT3
+//  9    | OUT1C   | TX3 RX3 | GPIO_B0_11_ALT3
+//  6    | OUT1D   | TX4 RX2 | GPIO_B0_10_ALT3
+//  8    | IN1     |     RX1 | GPIO_B1_00_ALT3
+#ifndef AUDIO_N_SAI1_RX_DATAPINS
+#define AUDIO_N_SAI1_RX_DATAPINS 1
+#endif
+
+#ifndef AUDIO_N_SAI1_TX_DATAPINS
+#define AUDIO_N_SAI1_TX_DATAPINS 1
+#endif
+
+# if (AUDIO_N_SAI1_RX_DATAPINS > 4  || AUDIO_N_SAI1_RX_DATAPINS < 1)
+#error SAI1 may have between 1 and 4 (inclusive) data pins for RX
+#endif
+# if (AUDIO_N_SAI1_TX_DATAPINS > 4  || AUDIO_N_SAI1_TX_DATAPINS < 1)
+#error SAI1 may have between 1 and 4 (inclusive) data pins for TX
+#endif
+
+#if (AUDIO_N_SAI1_RX_DATAPINS + AUDIO_N_SAI1_TX_DATAPINS > 5)
+#error SAI1 has only 5 data pins.  You ve asked for too many.
+#endif
+
+#define USB_AUDIO_BYTES_PER_SAMPLE 2 /* warning... don't change this... it's not easily changeable yet, */
+#define USB_AUDIO_BYTES_PER_TX_FRAME (USB_AUDIO_TX_CHANNELS*USB_AUDIO_BYTES_PER_SAMPLE)
+#define USB_AUDIO_BYTES_PER_RX_FRAME (USB_AUDIO_RX_CHANNELS*USB_AUDIO_BYTES_PER_SAMPLE)
+
+/* This isn't a parameter... yet.  Don't change it.. */
+#define TDM_CHANNELS_PER_PIN 16
+
+/*
+  AUDIO_TX_SIZE and AUDIO_RX_SIZE are the maximum TX and RX sizes
+  respectively, IN BYTES.  
+   
+  for 44.1khz, 16-bits, the number of bytes per 1ms usb frame is
+     44100 af     sec        2 channels    2 bytes      176.4 bytes
+   ----------- * -------- * ---------- * ------------ = -----------
+      sec         1000 uf     audio_frame    sample      uf
+
+  where:
+     af     : audio_frame (i.e. what you typically call a sample)
+     sample : an actual, single sample representing one channel, at one time
+     uf     : usb frame.  1khz for full speed
+     channel: channel is made up of 1 sample for every channel in the stream
+
+  for 44.1khz, you must transmit an average of 176.4 bytes, which is
+  44.1 audio_frame per usb_frame, so sometimes you need to transmit 44
+  and somteims you need to transmit 45. So buffer sizes need to be 
+
+  45 * 2 channels * 2 bytes = 180 bytes.
+  
+  For 48000, it's exactly 48000/1000 = 48 audio_frames/usb_frame.
+  Unfortunately, the USB 1khz rate isn't exactly the same as the
+  audio's 1khz rate, so you might sometimes need to transmit one extra
+  'makeup' frame sometimes, depening on the synchronization method.
+  
+  In which case it would be
+  (48+1) audio_frames * 2 channels * 2 bytes = 192 bytes
+*/
+
+#if AUDIO_SAMPLE_RATE == 44100
+  #define AUDIO_BASEFRAMES (44)
+// Send an extra frame every 10 usb frames */
+  #define AUDIO_BASEFRAMES_EXTRA (10)
+#elif AUDIO_SAMPLE_RATE == 48000
+#define AUDIO_BASEFRAMES (48)
+#elif AUDIO_SAMPLE_RATE == 32000
+  #define AUDIO_BASEFRAMES (32)
+#elif AUDIO_SAMPLE_RATE == 16000
+  #define AUDIO_BASEFRAMES (16)
+#elif AUDIO_SAMPLE_RATE ==  8000
+  #define AUDIO_BASEFRAMES (8)
+#else
+#error UNSUPPORTED SAMPLE RATE, or you have specified a FLOAT.  Currently supported rates are 44100, 48000, 32000, 16000, 8000.   Set AUDIO_SAMPLE_RATE=<one of the above>
+#endif
+
+#ifndef AUDIO_BASEFRAMES_EXTRA
+// the even multiples of 1kHz don't need any extra frames typically.
+#define AUDIO_BASEFRAMES_EXTRA 0
+#endif
+
+// We still need a +1 to BASEFRAMES because we still need the ability to transmit
+// one extra frame when the USB host is consuming frames too quickly.
+#define AUDIO_TX_SIZE         ((AUDIO_BASEFRAMES+1) * USB_AUDIO_TX_CHANNELS * USB_AUDIO_BYTES_PER_SAMPLE)
+#define AUDIO_RX_SIZE         ((AUDIO_BASEFRAMES+1) * USB_AUDIO_RX_CHANNELS * USB_AUDIO_BYTES_PER_SAMPLE)
+
+#ifndef AUDIO_N_SAI1_RX_DATAPINS
+#    define AUDIO_N_SAI1_RX_DATAPINS (1)
+#endif
+
+#ifndef AUDIO_N_SAI1_TX_DATAPINS
+#    define AUDIO_N_SAI1_TX_DATAPINS (1)
+#endif
+
+#ifndef TDM_CHANNELS_PER_PIN
+#define TDM_CHANNELS_PER_PIN (16)
+#endif
+
+#endif
diff --git a/teensy4/AudioStream.h b/teensy4/AudioStream.h
index 90f0b0da2..57f53443e 100644
--- a/teensy4/AudioStream.h
+++ b/teensy4/AudioStream.h
@@ -54,11 +54,7 @@
 #define AUDIO_BLOCK_SAMPLES  128
 #endif
 
-#ifndef AUDIO_SAMPLE_RATE_EXACT
-#define AUDIO_SAMPLE_RATE_EXACT 44100.0f
-#endif
-
-#define AUDIO_SAMPLE_RATE AUDIO_SAMPLE_RATE_EXACT
+#include "AudioRate.h"
 
 #define noAUDIO_DEBUG_CLASS // disable this class by default
 
diff --git a/teensy4/imxrt.h b/teensy4/imxrt.h
index 4770d9a8d..af94d3770 100644
--- a/teensy4/imxrt.h
+++ b/teensy4/imxrt.h
@@ -8395,6 +8395,11 @@ typedef struct {
 #define I2S_RCR4_SYWD(n)		((uint32_t)((n) & 0x1f)<<8)	// Sync Width
 #define I2S_RCR4_FRSZ(n)		((uint32_t)((n) & 0x0f)<<16)	// Frame Size
 #define I2S_RCR4_FCONT			((uint32_t)1<<28)	// FIFO Continue on Error
+#define I2S_RCR4_FCOMB(n)               ((uint32_t)(n & 0x3)<<26)	// FIFO Combine Mode
+#define I2S_RCR4_FCOMB_DISABLED          I2S_RCR4_FCOMB(0) // No FIFO combining
+#define I2S_RCR4_FCOMB_ENABLED_ON_WRITES I2S_RCR4_FCOMB(1) // <-- this is the one you want.
+#define I2S_RCR4_FCOMB_ENABLED_ON_READS  I2S_RCR4_FCOMB(2) 
+#define I2S_RCR4_FCOMB_ENABLED_ON_RW     I2S_RCR4_FCOMB(3)
 #define I2S_RCR5_FBT(n)			((uint32_t)((n) & 0x1f)<<8)	// First Bit Shifted
 #define I2S_RCR5_W0W(n)			((uint32_t)((n) & 0x1f)<<16)	// Word 0 Width
 #define I2S_RCR5_WNW(n)			((uint32_t)((n) & 0x1f)<<24)	// Word N Width
@@ -8419,6 +8424,11 @@ typedef struct {
 #define I2S_TCR4_SYWD(n)		((uint32_t)((n) & 0x1f)<<8)	// Sync Width
 #define I2S_TCR4_FRSZ(n)		((uint32_t)((n) & 0x0f)<<16)	// Frame Size
 #define I2S_TCR4_FCONT			((uint32_t)1<<28)	// FIFO Continue on Error
+#define I2S_TCR4_FCOMB(n)               ((uint32_t)(n & 0x3)<<26)	// FIFO Combine Mode
+#define I2S_TCR4_FCOMB_DISABLED          I2S_TCR4_FCOMB(0)
+#define I2S_TCR4_FCOMB_ENABLED_ON_READS  I2S_TCR4_FCOMB(1) // <--- this is the one you want
+#define I2S_TCR4_FCOMB_ENABLED_ON_WRITES I2S_TCR4_FCOMB(2)
+#define I2S_TCR4_FCOMB_ENABLED_ON_RW     I2S_TCR4_FCOMB(3)
 #define I2S_TCR5_FBT(n)			((uint32_t)((n) & 0x1f)<<8) 	// First Bit Shifted
 #define I2S_TCR5_W0W(n)			((uint32_t)((n) & 0x1f)<<16)	// Word 0 Width
 #define I2S_TCR5_WNW(n)			((uint32_t)((n) & 0x1f)<<24)	// Word N Width
diff --git a/teensy4/usb_audio.cpp b/teensy4/usb_audio.cpp
index fa492a599..ec7c50373 100644
--- a/teensy4/usb_audio.cpp
+++ b/teensy4/usb_audio.cpp
@@ -32,14 +32,15 @@
 #include "usb_dev.h"
 #include "usb_audio.h"
 #include "debug/printf.h"
+extern void debug_toggle(int pin);
+extern void debug_pin_high(int pin);
+extern void debug_pin_low(int pin);
 
 #ifdef AUDIO_INTERFACE
 
 bool AudioInputUSB::update_responsibility;
-audio_block_t * AudioInputUSB::incoming_left;
-audio_block_t * AudioInputUSB::incoming_right;
-audio_block_t * AudioInputUSB::ready_left;
-audio_block_t * AudioInputUSB::ready_right;
+audio_block_t * AudioInputUSB::incoming[USB_AUDIO_RX_CHANNELS];
+audio_block_t * AudioInputUSB::ready[USB_AUDIO_RX_CHANNELS];
 uint16_t AudioInputUSB::incoming_count;
 uint8_t AudioInputUSB::receive_flag;
 
@@ -53,7 +54,7 @@ static void tx_event(transfer_t *t);
 /*static*/ transfer_t sync_transfer __attribute__ ((used, aligned(32)));
 /*static*/ transfer_t tx_transfer __attribute__ ((used, aligned(32)));
 DMAMEM static uint8_t rx_buffer[AUDIO_RX_SIZE] __attribute__ ((aligned(32)));
-DMAMEM static uint8_t tx_buffer[AUDIO_RX_SIZE] __attribute__ ((aligned(32)));
+DMAMEM static uint8_t tx_buffer[AUDIO_TX_SIZE] __attribute__ ((aligned(32)));
 DMAMEM uint32_t usb_audio_sync_feedback __attribute__ ((aligned(32)));
 
 uint8_t usb_audio_receive_setting=0;
@@ -94,7 +95,12 @@ void usb_audio_configure(void)
 	printf("usb_audio_configure\n");
 	usb_audio_underrun_count = 0;
 	usb_audio_overrun_count = 0;
-	feedback_accumulator = 739875226; // 44.1 * 2^24
+
+        // feedback_accumulator is (sample_rate_khz * 2^24).
+        // using doubles makes it easy to get numerical perfection.
+        // not sure if it's necessary or not.
+        // floats don't give perfect answers.
+        feedback_accumulator = (int)(((double)AUDIO_SAMPLE_RATE / 1000.0f * 0x1000000)+0.5);
 	if (usb_high_speed) {
 		usb_audio_sync_nbytes = 4;
 		usb_audio_sync_rshift = 8;
@@ -116,11 +122,11 @@ void usb_audio_configure(void)
 void AudioInputUSB::begin(void)
 {
 	incoming_count = 0;
-	incoming_left = NULL;
-	incoming_right = NULL;
-	ready_left = NULL;
-	ready_right = NULL;
-	receive_flag = 0;
+  for (unsigned int i = 0; i < USB_AUDIO_RX_CHANNELS; i++) {
+    incoming[i] = NULL;
+    ready[i] = NULL;
+  }
+  receive_flag = 0;
 	// update_responsibility = update_setup();
 	// TODO: update responsibility is tough, partly because the USB
 	// interrupts aren't sychronous to the audio library block size,
@@ -129,118 +135,129 @@ void AudioInputUSB::begin(void)
 	update_responsibility = false;
 }
 
-static void copy_to_buffers(const uint32_t *src, int16_t *left, int16_t *right, unsigned int len)
+/* 
+   Copy data from *interleaved* int16 data in src, to deinterleaved data in channel data
+   start copying into channel_data at offset, and copy len_frames frames.
+*/
+static void copy_to_buffers(const uint16_t *src, audio_block_t *channel_data[USB_AUDIO_RX_CHANNELS], uint32_t offset, unsigned int len_frames)
 {
-	uint32_t *target = (uint32_t*) src + len; 
-	while ((src < target) && (((uintptr_t) left & 0x02) != 0)) {
-		uint32_t n = *src++;
-		*left++ = n & 0xFFFF;
-		*right++ = n >> 16;
-	}
+        int16_t *dest_ptrs[USB_AUDIO_RX_CHANNELS];
 
-	while ((src < target - 2)) {
-		uint32_t n1 = *src++;
-		uint32_t n = *src++;
-		*(uint32_t *)left = (n1 & 0xFFFF) | ((n & 0xFFFF) << 16);
-		left+=2;
-		*(uint32_t *)right = (n1 >> 16) | ((n & 0xFFFF0000)) ;
-		right+=2;
-	}
+        for (unsigned int channel = 0; channel < USB_AUDIO_RX_CHANNELS; channel++)
+                dest_ptrs[channel] = channel_data[channel]->data + offset;
 
-	while ((src < target)) {
-		uint32_t n = *src++;
-		*left++ = n & 0xFFFF;
-		*right++ = n >> 16;
-	}
+        for (unsigned int frame = 0; frame < len_frames; frame++) {
+                for (unsigned int channel = 0; channel < USB_AUDIO_RX_CHANNELS; channel++) {
+                        *(dest_ptrs[channel]) = *src++;
+                        dest_ptrs[channel]++;
+                }
+        }
 }
 
 // Called from the USB interrupt when an isochronous packet arrives
 // we must completely remove it from the receive buffer before returning
 //
-#if 1
-void usb_audio_receive_callback(unsigned int len)
+static audio_block_t *channel_data[USB_AUDIO_RX_CHANNELS];
+void usb_audio_receive_callback(unsigned int len_bytes)
 {
-	unsigned int count, avail;
-	audio_block_t *left, *right;
-	const uint32_t *data;
-
-	AudioInputUSB::receive_flag = 1;
-	len >>= 2; // 1 sample = 4 bytes: 2 left, 2 right
-	data = (const uint32_t *)rx_buffer;
-
-	count = AudioInputUSB::incoming_count;
-	left = AudioInputUSB::incoming_left;
-	right = AudioInputUSB::incoming_right;
-	if (left == NULL) {
-		left = AudioStream::allocate();
-		if (left == NULL) return;
-		AudioInputUSB::incoming_left = left;
-	}
-	if (right == NULL) {
-		right = AudioStream::allocate();
-		if (right == NULL) return;
-		AudioInputUSB::incoming_right = right;
-	}
-	while (len > 0) {
-		avail = AUDIO_BLOCK_SAMPLES - count;
-		if (len < avail) {
-			copy_to_buffers(data, left->data + count, right->data + count, len);
-			AudioInputUSB::incoming_count = count + len;
-			return;
-		} else if (avail > 0) {
-			copy_to_buffers(data, left->data + count, right->data + count, avail);
-			data += avail;
-			len -= avail;
-			if (AudioInputUSB::ready_left || AudioInputUSB::ready_right) {
-				// buffer overrun, PC sending too fast
-				AudioInputUSB::incoming_count = count + avail;
-				if (len > 0) {
-					usb_audio_overrun_count++;
-					printf("!");
-					//serial_phex(len);
-				}
-				return;
-			}
-			send:
-			AudioInputUSB::ready_left = left;
-			AudioInputUSB::ready_right = right;
-			//if (AudioInputUSB::update_responsibility) AudioStream::update_all();
-			left = AudioStream::allocate();
-			if (left == NULL) {
-				AudioInputUSB::incoming_left = NULL;
-				AudioInputUSB::incoming_right = NULL;
-				AudioInputUSB::incoming_count = 0;
-				return;
-			}
-			right = AudioStream::allocate();
-			if (right == NULL) {
-				AudioStream::release(left);
-				AudioInputUSB::incoming_left = NULL;
-				AudioInputUSB::incoming_right = NULL;
-				AudioInputUSB::incoming_count = 0;
-				return;
-			}
-			AudioInputUSB::incoming_left = left;
-			AudioInputUSB::incoming_right = right;
-			count = 0;
-		} else {
-			if (AudioInputUSB::ready_left || AudioInputUSB::ready_right) return;
-			goto send; // recover from buffer overrun
-		}
-	}
-	AudioInputUSB::incoming_count = count;
+        AudioInputUSB::receive_flag = 1;
+
+        // 1 frame = 4 bytes: 2 left, 2 right for stereo
+        // len_frames this is the number of frames coming in from the USB.
+        uint32_t len_frames = len_bytes/USB_AUDIO_BYTES_PER_SAMPLE/USB_AUDIO_RX_CHANNELS;
+
+        int allocate_errors = 0;
+        for (unsigned int i = 0; i < USB_AUDIO_RX_CHANNELS; i++) {
+                channel_data[i] = AudioInputUSB::incoming[i];
+                if (channel_data[i] == NULL) {
+                        channel_data[i] = AudioStream::allocate();
+                        if (channel_data[i] == NULL) {
+                                allocate_errors++;
+                                break;
+                        }
+                        AudioInputUSB::incoming[i] = channel_data[i];
+                }
+        }
+        if (allocate_errors) {
+                // release any blocks allocated above.
+                for (unsigned int i = 0; i < USB_AUDIO_RX_CHANNELS; i++) {
+                        if (channel_data[i])
+                                AudioStream::release(channel_data[i]);
+                        channel_data[i] = NULL;
+                }
+                return;
+        }
+
+        // count_frames is the number of frames currently occupied in the output
+        // buffers.  There can be up to AUDIO_BLOCK_SAMPLES occupied
+        const uint16_t *data = (const uint16_t *)rx_buffer;
+        uint32_t count_frames = AudioInputUSB::incoming_count;
+        while (len_frames > 0) {
+                // avail_frames: the number of empty frames to shove into each output's buffer.
+                uint32_t avail_frames = AUDIO_BLOCK_SAMPLES - count_frames;
+                if (len_frames < avail_frames) {
+                        // copy all the frames from USB and deinterleave and copy to buffers.
+                        // there's space in the outputs buffers, so do them all at once
+                        copy_to_buffers(data, channel_data, count_frames, len_frames);
+                        AudioInputUSB::incoming_count = count_frames + len_frames;
+                        return;
+                } else if (avail_frames > 0) {
+                        // there's some space for new samples, but not enough for all the new samples.
+                        copy_to_buffers(data, channel_data, count_frames, avail_frames);
+                        data += avail_frames * USB_AUDIO_RX_CHANNELS; // skip data pointer ahead
+                        len_frames -= avail_frames;
+                        if (AudioInputUSB::all_ready()) {
+                                // buffer overrun, PC sending too fast
+                                AudioInputUSB::incoming_count = count_frames + avail_frames;
+                                if (len_frames > 0) {
+                                        usb_audio_overrun_count++;
+                                        printf("!");
+                                        //serial_phex(len_frames);
+                                }
+                                return;
+                        }
+                send:
+                        for (unsigned int i = 0; i < USB_AUDIO_RX_CHANNELS; i++) {
+                                AudioInputUSB::ready[i] = channel_data[i];
+                        }
+                        //if (AudioInputUSB::update_responsibility) AudioStream::update_all();
+                        for (unsigned int i = 0; i < USB_AUDIO_RX_CHANNELS; i++) {
+                                channel_data[i] = AudioStream::allocate();
+                                if (channel_data[i] == NULL) {
+                                        for (unsigned int j = 0; j < USB_AUDIO_RX_CHANNELS; j++) {
+                                                AudioInputUSB::incoming[j] = NULL;
+                                                AudioInputUSB::incoming_count = 0;
+                                        }
+                                        break;
+                                }
+                                AudioInputUSB::incoming[i] = channel_data[i];
+                        }
+                        count_frames = 0;
+                } else {
+                        if (AudioInputUSB::all_ready()) return;
+                        goto send; // recover from buffer overrun
+                }
+        }
+        AudioInputUSB::incoming_count = count_frames;
+}
+
+int AudioInputUSB::all_ready(void) {
+        int r = 0;
+        // logical or || of (ready[x])
+        for (unsigned int i = 0; i < USB_AUDIO_RX_CHANNELS; i++) {
+                r += (ready[i]!=NULL);
+        }
+        return (r > 0);
 }
-#endif
 
 void AudioInputUSB::update(void)
 {
-	audio_block_t *left, *right;
-
+	audio_block_t *channels[USB_AUDIO_RX_CHANNELS];
 	__disable_irq();
-	left = ready_left;
-	ready_left = NULL;
-	right = ready_right;
-	ready_right = NULL;
+        for (unsigned int channel = 0; channel < USB_AUDIO_RX_CHANNELS; channel++) {
+                channels[channel] = ready[channel];
+                ready[channel] = NULL;
+        }
 	uint16_t c = incoming_count;
 	uint8_t f = receive_flag;
 	receive_flag = 0;
@@ -255,19 +272,21 @@ void AudioInputUSB::update(void)
 	}
 	//serial_phex(c);
 	//serial_print(".");
-	if (!left || !right) {
-		usb_audio_underrun_count++;
-		//printf("#"); // buffer underrun - PC sending too slow
-		if (f) feedback_accumulator += 3500;
-	}
-	if (left) {
-		transmit(left, 0);
-		release(left);
-	}
-	if (right) {
-		transmit(right, 1);
-		release(right);
+        for (unsigned int channel = 0, underrun = 0; channel < USB_AUDIO_RX_CHANNELS; channel++) {
+                if (!channels[channel]) {
+                        underrun ++;
+                        usb_audio_underrun_count++;
+                        //printf("#"); // buffer underrun - PC sending too slow
+                        if (f) feedback_accumulator += 3500;
+                        break;
+                }
 	}
+        for (unsigned int channel = 0; channel < USB_AUDIO_RX_CHANNELS; channel++) {
+                if (channels[channel]) {
+                        transmit(channels[channel], channel);
+                        release(channels[channel]);
+                }
+        }
 }
 
 
@@ -288,10 +307,8 @@ void AudioInputUSB::update(void)
 
 #if 1
 bool AudioOutputUSB::update_responsibility;
-audio_block_t * AudioOutputUSB::left_1st;
-audio_block_t * AudioOutputUSB::left_2nd;
-audio_block_t * AudioOutputUSB::right_1st;
-audio_block_t * AudioOutputUSB::right_2nd;
+audio_block_t * AudioOutputUSB::chan_1st[USB_AUDIO_TX_CHANNELS];
+audio_block_t * AudioOutputUSB::chan_2nd[USB_AUDIO_TX_CHANNELS];
 uint16_t AudioOutputUSB::offset_1st;
 
 /*DMAMEM*/ uint16_t usb_audio_transmit_buffer[AUDIO_TX_SIZE/2] __attribute__ ((used, aligned(32)));
@@ -310,78 +327,118 @@ static void tx_event(transfer_t *t)
 void AudioOutputUSB::begin(void)
 {
 	update_responsibility = false;
-	left_1st = NULL;
-	right_1st = NULL;
+        for (uint32_t i = 0; i < USB_AUDIO_TX_CHANNELS; i++) {
+                chan_1st[i] = NULL;
+        }
 }
 
-static void copy_from_buffers(uint32_t *dst, int16_t *left, int16_t *right, unsigned int len)
+static void copy_from_buffers(uint16_t *dst, audio_block_t *channel_data[USB_AUDIO_TX_CHANNELS], uint32_t offset, unsigned int len_frames)
 {
-	// TODO: optimize...
-	while (len > 0) {
-		*dst++ = (*right++ << 16) | (*left++ & 0xFFFF);
-		len--;
-	}
+  // TODO: optimize...
+  int16_t *src_ptrs[USB_AUDIO_TX_CHANNELS];
+  
+  for (uint32_t channel = 0; channel < USB_AUDIO_TX_CHANNELS; channel++)
+    src_ptrs[channel] = channel_data[channel]->data + offset;
+  
+  while (len_frames > 0) {
+    for (uint32_t channel = 0; channel < USB_AUDIO_TX_CHANNELS; channel++)
+      *dst++ = *src_ptrs[channel]++;
+    len_frames--;
+  }
+}
+
+
+int AudioOutputUSB::allocate_tx_blocks(audio_block_t *blocks[USB_AUDIO_TX_CHANNELS])
+{
+  int alloc_errors = 0;
+  // Try to allocate all blocks
+  for (uint32_t channel = 0; channel < USB_AUDIO_TX_CHANNELS; channel++) {
+    if (blocks[channel] == NULL) {
+      blocks[channel] = allocate();
+      if (blocks[channel] == NULL) {
+        alloc_errors++;
+        break;
+      }
+      memset(blocks[channel]->data, 0, sizeof(blocks[channel]->data));
+    }
+  }
+  // Release on error
+  if (alloc_errors) {
+    for (uint32_t channel = 0; channel < USB_AUDIO_TX_CHANNELS; channel++) {
+      if (blocks[channel]) {
+        release(blocks[channel]);
+        blocks[channel] = NULL;
+      }
+    }
+  }
+  return alloc_errors;
 }
 
 void AudioOutputUSB::update(void)
 {
-	audio_block_t *left, *right;
+	audio_block_t *blocks[USB_AUDIO_TX_CHANNELS];
 
 	// TODO: we shouldn't be writing to these......
 	//left = receiveReadOnly(0); // input 0 = left channel
 	//right = receiveReadOnly(1); // input 1 = right channel
-	left = receiveWritable(0); // input 0 = left channel
-	right = receiveWritable(1); // input 1 = right channel
+  for (uint32_t channel = 0; channel < USB_AUDIO_TX_CHANNELS; channel++)
+    blocks[channel] = receiveWritable(channel);
+
 	if (usb_audio_transmit_setting == 0) {
-		if (left) release(left);
-		if (right) release(right);
-		if (left_1st) { release(left_1st); left_1st = NULL; }
-		if (left_2nd) { release(left_2nd); left_2nd = NULL; }
-		if (right_1st) { release(right_1st); right_1st = NULL; }
-		if (right_2nd) { release(right_2nd); right_2nd = NULL; }
+    for (uint32_t channel = 0; channel < USB_AUDIO_TX_CHANNELS; channel++) {
+      if (blocks[channel]) release(blocks[channel]);
+      if (chan_1st[channel]) { release(chan_1st[channel]); chan_1st[channel] = NULL;}
+      if (chan_2nd[channel]) { release(chan_2nd[channel]); chan_2nd[channel] = NULL;}
+    }
 		offset_1st = 0;
 		return;
 	}
-	if (left == NULL) {
-		left = allocate();
-		if (left == NULL) {
-			if (right) release(right);
-			return;
-		}
-		memset(left->data, 0, sizeof(left->data));
-	}
-	if (right == NULL) {
-		right = allocate();
-		if (right == NULL) {
-			release(left);
-			return;
-		}
-		memset(right->data, 0, sizeof(right->data));
-	}
+
+  int alloc_errors = allocate_tx_blocks(blocks);
+  if (alloc_errors)
+    return;
+
 	__disable_irq();
-	if (left_1st == NULL) {
-		left_1st = left;
-		right_1st = right;
+  
+	if (chan_1st[0] == NULL) {
+    for (uint32_t channel = 0; channel < USB_AUDIO_TX_CHANNELS; channel++)
+      chan_1st[channel] = blocks[channel];
 		offset_1st = 0;
-	} else if (left_2nd == NULL) {
-		left_2nd = left;
-		right_2nd = right;
+	} else if (chan_2nd[0] == NULL) {
+    for (uint32_t channel = 0; channel < USB_AUDIO_TX_CHANNELS; channel++)
+      chan_2nd[channel] = blocks[channel];
 	} else {
 		// buffer overrun - PC is consuming too slowly
-		audio_block_t *discard1 = left_1st;
-		left_1st = left_2nd;
-		left_2nd = left;
-		audio_block_t *discard2 = right_1st;
-		right_1st = right_2nd;
-		right_2nd = right;
+    audio_block_t *discard;
+    for (uint32_t channel = 0; channel < USB_AUDIO_TX_CHANNELS; channel++) {
+      discard = chan_1st[channel];
+      chan_1st[channel] = chan_2nd[channel];
+      chan_2nd[channel] = blocks[channel];
+      release(discard);
+    }
 		offset_1st = 0; // TODO: discard part of this data?
 		//serial_print("*");
-		release(discard1);
-		release(discard2);
 	}
 	__enable_irq();
 }
 
+void inject_ramp(uint32_t target, uint16_t *buffer) {
+#ifdef INJECT_RECORD_RAMP
+  static uint16_t ramp = 0;
+  uint16_t *ptr = (uint16_t *)buffer;
+  for (uint32_t i = 0; i < target; i++, ramp++) {
+    for (uint32_t channel = 0; channel < USB_AUDIO_TX_CHANNELS; channel++) {
+      uint16_t v = ramp;
+      if (channel > 31)
+        v >>=2;
+      else if (channel >15)
+        v >>=1;
+      v &= 0x0FFF;
+      *ptr++ = v + (channel << 12);
+    }
+  }
+#endif  
+}
 
 // Called from the USB interrupt when ready to transmit another
 // isochronous packet.  If we place data into the transmit buffer,
@@ -389,48 +446,53 @@ void AudioOutputUSB::update(void)
 // no data to transmit
 unsigned int usb_audio_transmit_callback(void)
 {
-	static uint32_t count=5;
-	uint32_t avail, num, target, offset, len=0;
-	audio_block_t *left, *right;
+	static uint32_t count=AUDIO_BASEFRAMES_EXTRA>>1;
+	uint32_t target, len_frames=0;
+	audio_block_t *blocks[USB_AUDIO_TX_CHANNELS];
 
-	if (++count < 10) {   // TODO: dynamic adjust to match USB rate
-		target = 44;
+  target = AUDIO_BASEFRAMES;
+	if (++count < AUDIO_BASEFRAMES_EXTRA) {   // TODO: dynamic adjust to match USB rate
 	} else {
+    // for 44.1, every 10 usb frames, add an extra to the target
 		count = 0;
-		target = 45;
+    if (AUDIO_BASEFRAMES_EXTRA > 0)
+      target++;
 	}
-	while (len < target) {
-		num = target - len;
-		left = AudioOutputUSB::left_1st;
-		if (left == NULL) {
+	while (len_frames < target) {
+    uint32_t num_frames = target - len_frames;
+		if (AudioOutputUSB::chan_1st[0] == NULL) {
 			// buffer underrun - PC is consuming too quickly
-			memset(usb_audio_transmit_buffer + len, 0, num * 4);
+			memset(usb_audio_transmit_buffer + len_frames, 0, num_frames * USB_AUDIO_BYTES_PER_TX_FRAME);
 			//serial_print("%");
 			break;
 		}
-		right = AudioOutputUSB::right_1st;
-		offset = AudioOutputUSB::offset_1st;
-
-		avail = AUDIO_BLOCK_SAMPLES - offset;
-		if (num > avail) num = avail;
-
-		copy_from_buffers((uint32_t *)usb_audio_transmit_buffer + len,
-			left->data + offset, right->data + offset, num);
-		len += num;
-		offset += num;
+    for (uint32_t channel = 0; channel < USB_AUDIO_TX_CHANNELS; channel++) {
+      blocks[channel] = AudioOutputUSB::chan_1st[channel];
+    }
+		uint32_t offset = AudioOutputUSB::offset_1st;
+
+		uint32_t avail_frames = AUDIO_BLOCK_SAMPLES - offset;
+		if (num_frames > avail_frames) num_frames = avail_frames;
+
+		copy_from_buffers(usb_audio_transmit_buffer + len_frames*USB_AUDIO_TX_CHANNELS,
+                      blocks, offset, num_frames);
+		len_frames += num_frames;
+		offset += num_frames;
 		if (offset >= AUDIO_BLOCK_SAMPLES) {
-			AudioStream::release(left);
-			AudioStream::release(right);
-			AudioOutputUSB::left_1st = AudioOutputUSB::left_2nd;
-			AudioOutputUSB::left_2nd = NULL;
-			AudioOutputUSB::right_1st = AudioOutputUSB::right_2nd;
-			AudioOutputUSB::right_2nd = NULL;
-			AudioOutputUSB::offset_1st = 0;
+      for (uint32_t channel = 0; channel < USB_AUDIO_TX_CHANNELS; channel++) {
+        AudioStream::release(blocks[channel]);
+        AudioOutputUSB::chan_1st[channel] = AudioOutputUSB::chan_2nd[channel];
+        AudioOutputUSB::chan_2nd[channel] = NULL;
+      }
+      AudioOutputUSB::offset_1st = 0;
 		} else {
 			AudioOutputUSB::offset_1st = offset;
 		}
 	}
-	return target * 4;
+  uint32_t nbytes = target * USB_AUDIO_BYTES_PER_TX_FRAME;
+
+  inject_ramp(target, usb_audio_transmit_buffer);
+  return nbytes;
 }
 #endif
 
diff --git a/teensy4/usb_audio.h b/teensy4/usb_audio.h
index a53d6be74..089b674da 100644
--- a/teensy4/usb_audio.h
+++ b/teensy4/usb_audio.h
@@ -78,29 +78,28 @@ class AudioInputUSB : public AudioStream
 	}
 private:
 	static bool update_responsibility;
-	static audio_block_t *incoming_left;
-	static audio_block_t *incoming_right;
-	static audio_block_t *ready_left;
-	static audio_block_t *ready_right;
+	static audio_block_t *incoming[USB_AUDIO_RX_CHANNELS];
+	static audio_block_t *ready[USB_AUDIO_RX_CHANNELS];
 	static uint16_t incoming_count;
 	static uint8_t receive_flag;
+	static int all_ready(void);
 };
 
 class AudioOutputUSB : public AudioStream
 {
 public:
-	AudioOutputUSB(void) : AudioStream(2, inputQueueArray) { begin(); }
+	AudioOutputUSB(void) : AudioStream(USB_AUDIO_TX_CHANNELS, inputQueueArray) { begin(); }
 	virtual void update(void);
 	void begin(void);
 	friend unsigned int usb_audio_transmit_callback(void);
 private:
 	static bool update_responsibility;
-	static audio_block_t *left_1st;
-	static audio_block_t *left_2nd;
-	static audio_block_t *right_1st;
-	static audio_block_t *right_2nd;
+	static audio_block_t *chan_1st[USB_AUDIO_TX_CHANNELS];
+	static audio_block_t *chan_2nd[USB_AUDIO_TX_CHANNELS];
 	static uint16_t offset_1st;
-	audio_block_t *inputQueueArray[2];
+	audio_block_t *inputQueueArray[USB_AUDIO_TX_CHANNELS];
+        static int allocate_tx_blocks(audio_block_t *blocks[USB_AUDIO_TX_CHANNELS]);
+
 };
 #endif // __cplusplus
 
diff --git a/teensy4/usb_desc.c b/teensy4/usb_desc.c
index 010e3efb4..909f76af9 100644
--- a/teensy4/usb_desc.c
+++ b/teensy4/usb_desc.c
@@ -71,6 +71,17 @@
 
 #define LSB(n) ((n) & 255)
 #define MSB(n) (((n) >> 8) & 255)
+#define MMSB(n) (((n) >> 16) & 255)
+#define TSAMFREQ LSB(AUDIO_SAMPLE_RATE), MSB(AUDIO_SAMPLE_RATE), MMSB(AUDIO_SAMPLE_RATE)
+
+// This defines the channel config, which is basically a
+// '1' in every bit, filling from the LSbit for each channel.
+// when the number of channels is > 16, just fill the
+// wChannelCoinfig with all 1s.
+#define WCHANNELCONFIG(N_CHANNELS)                      \
+    (uint8_t) ((N_CHANNELS<16) ? LSB((1ULL<<N_CHANNELS)-1) : 0xff), \
+    (uint8_t) ((N_CHANNELS<16) ? MSB((1ULL<<N_CHANNELS)-1) : 0xff)
+
 
 #ifdef CDC_IAD_DESCRIPTOR
 #ifndef DEVICE_CLASS
@@ -1444,8 +1455,8 @@ PROGMEM const uint8_t usb_config_descriptor_480[CONFIG_DESC_SIZE] = {
 	//0x03, 0x06,				// wTerminalType, 0x0603 = Line Connector
 	0x02, 0x06,				// wTerminalType, 0x0602 = Digital Audio
 	0,					// bAssocTerminal, 0 = unidirectional
-	2,					// bNrChannels
-	0x03, 0x00,				// wChannelConfig, 0x0003 = Left & Right Front
+	USB_AUDIO_TX_CHANNELS,			// bNrChannels
+	WCHANNELCONFIG(USB_AUDIO_TX_CHANNELS),	// wChannelConfig, 0x0003 = Left & Right Front.
 	0,					// iChannelNames
 	0, 					// iTerminal
 	// Output Terminal Descriptor
@@ -1466,8 +1477,8 @@ PROGMEM const uint8_t usb_config_descriptor_480[CONFIG_DESC_SIZE] = {
 	3,					// bTerminalID
 	0x01, 0x01,				// wTerminalType, 0x0101 = USB_STREAMING
 	0,					// bAssocTerminal, 0 = unidirectional
-	2,					// bNrChannels
-	0x03, 0x00,				// wChannelConfig, 0x0003 = Left & Right Front
+	USB_AUDIO_RX_CHANNELS,			// bNrChannels
+	WCHANNELCONFIG(USB_AUDIO_RX_CHANNELS),	// wChannelConfig, 0x0003 = Left & Right Front
 	0,					// iChannelNames
 	0, 					// iTerminal
 	// Volume feature descriptor
@@ -1528,11 +1539,11 @@ PROGMEM const uint8_t usb_config_descriptor_480[CONFIG_DESC_SIZE] = {
 	0x24,					// bDescriptorType = CS_INTERFACE
 	2,					// bDescriptorSubtype = FORMAT_TYPE
 	1,					// bFormatType = FORMAT_TYPE_I
-	2,					// bNrChannels = 2
+	USB_AUDIO_TX_CHANNELS,			// bNrChannels = 2
 	2,					// bSubFrameSize = 2 byte
 	16,					// bBitResolution = 16 bits
 	1,					// bSamFreqType = 1 frequency
-	LSB(44100), MSB(44100), 0,		// tSamFreq
+        TSAMFREQ,                               // tSamFreq
 	// Standard AS Isochronous Audio Data Endpoint Descriptor
 	// USB DCD for Audio Devices 1.0, Section 4.6.1.1, Table 4-20, page 61-62
 	9, 					// bLength
@@ -1587,11 +1598,11 @@ PROGMEM const uint8_t usb_config_descriptor_480[CONFIG_DESC_SIZE] = {
 	0x24,					// bDescriptorType = CS_INTERFACE
 	2,					// bDescriptorSubtype = FORMAT_TYPE
 	1,					// bFormatType = FORMAT_TYPE_I
-	2,					// bNrChannels = 2
+	USB_AUDIO_RX_CHANNELS,			// bNrChannels = 2
 	2,					// bSubFrameSize = 2 byte
 	16,					// bBitResolution = 16 bits
 	1,					// bSamFreqType = 1 frequency
-	LSB(44100), MSB(44100), 0,		// tSamFreq
+        TSAMFREQ,                               // tSamFreq
 	// Standard AS Isochronous Audio Data Endpoint Descriptor
 	// USB DCD for Audio Devices 1.0, Section 4.6.1.1, Table 4-20, page 61-62
 	9, 					// bLength
@@ -2458,8 +2469,8 @@ PROGMEM const uint8_t usb_config_descriptor_12[CONFIG_DESC_SIZE] = {
 	//0x03, 0x06,				// wTerminalType, 0x0603 = Line Connector
 	0x02, 0x06,				// wTerminalType, 0x0602 = Digital Audio
 	0,					// bAssocTerminal, 0 = unidirectional
-	2,					// bNrChannels
-	0x03, 0x00,				// wChannelConfig, 0x0003 = Left & Right Front
+	USB_AUDIO_TX_CHANNELS,			// bNrChannels
+	WCHANNELCONFIG(USB_AUDIO_TX_CHANNELS),	// wChannelConfig, 0x0003 = Left & Right Front.
 	0,					// iChannelNames
 	0, 					// iTerminal
 	// Output Terminal Descriptor
@@ -2480,8 +2491,8 @@ PROGMEM const uint8_t usb_config_descriptor_12[CONFIG_DESC_SIZE] = {
 	3,					// bTerminalID
 	0x01, 0x01,				// wTerminalType, 0x0101 = USB_STREAMING
 	0,					// bAssocTerminal, 0 = unidirectional
-	2,					// bNrChannels
-	0x03, 0x00,				// wChannelConfig, 0x0003 = Left & Right Front
+	USB_AUDIO_RX_CHANNELS,			// bNrChannels
+	WCHANNELCONFIG(USB_AUDIO_RX_CHANNELS),	// wChannelConfig, 0x0003 = Left & Right Front
 	0,					// iChannelNames
 	0, 					// iTerminal
 	// Volume feature descriptor
@@ -2542,11 +2553,11 @@ PROGMEM const uint8_t usb_config_descriptor_12[CONFIG_DESC_SIZE] = {
 	0x24,					// bDescriptorType = CS_INTERFACE
 	2,					// bDescriptorSubtype = FORMAT_TYPE
 	1,					// bFormatType = FORMAT_TYPE_I
-	2,					// bNrChannels = 2
+	USB_AUDIO_TX_CHANNELS,			// bNrChannels = 2
 	2,					// bSubFrameSize = 2 byte
 	16,					// bBitResolution = 16 bits
 	1,					// bSamFreqType = 1 frequency
-	LSB(44100), MSB(44100), 0,		// tSamFreq
+        TSAMFREQ,                               // tSamFreq
 	// Standard AS Isochronous Audio Data Endpoint Descriptor
 	// USB DCD for Audio Devices 1.0, Section 4.6.1.1, Table 4-20, page 61-62
 	9, 					// bLength
@@ -2601,11 +2612,11 @@ PROGMEM const uint8_t usb_config_descriptor_12[CONFIG_DESC_SIZE] = {
 	0x24,					// bDescriptorType = CS_INTERFACE
 	2,					// bDescriptorSubtype = FORMAT_TYPE
 	1,					// bFormatType = FORMAT_TYPE_I
-	2,					// bNrChannels = 2
+	USB_AUDIO_RX_CHANNELS,			// bNrChannels = 2
 	2,					// bSubFrameSize = 2 byte
 	16,					// bBitResolution = 16 bits
 	1,					// bSamFreqType = 1 frequency
-	LSB(44100), MSB(44100), 0,		// tSamFreq
+        TSAMFREQ,                               // tSamFreq
 	// Standard AS Isochronous Audio Data Endpoint Descriptor
 	// USB DCD for Audio Devices 1.0, Section 4.6.1.1, Table 4-20, page 61-62
 	9, 					// bLength
diff --git a/teensy4/usb_desc.h b/teensy4/usb_desc.h
index b4e6de7e7..2eb57e4e8 100644
--- a/teensy4/usb_desc.h
+++ b/teensy4/usb_desc.h
@@ -37,6 +37,7 @@
 
 #include <stdint.h>
 #include <stddef.h>
+#include "AudioRate.h"
 
 #define ENDPOINT_TRANSMIT_UNUSED	0x00020000
 #define ENDPOINT_TRANSMIT_ISOCHRONOUS	0x00C40000
@@ -762,9 +763,7 @@ let me know?  http://forum.pjrc.com/forums/4-Suggestions-amp-Bug-Reports
   #define SEREMU_RX_INTERVAL    2
   #define AUDIO_INTERFACE	1	// Audio (uses 3 consecutive interfaces)
   #define AUDIO_TX_ENDPOINT     3
-  #define AUDIO_TX_SIZE         180
   #define AUDIO_RX_ENDPOINT     3
-  #define AUDIO_RX_SIZE         180
   #define AUDIO_SYNC_ENDPOINT	4
   #define ENDPOINT2_CONFIG	ENDPOINT_RECEIVE_INTERRUPT + ENDPOINT_TRANSMIT_INTERRUPT
   #define ENDPOINT3_CONFIG	ENDPOINT_RECEIVE_ISOCHRONOUS + ENDPOINT_TRANSMIT_ISOCHRONOUS
@@ -801,9 +800,7 @@ let me know?  http://forum.pjrc.com/forums/4-Suggestions-amp-Bug-Reports
   #define MIDI_RX_SIZE_480      512
   #define AUDIO_INTERFACE	3	// Audio (uses 3 consecutive interfaces)
   #define AUDIO_TX_ENDPOINT     5
-  #define AUDIO_TX_SIZE         180
   #define AUDIO_RX_ENDPOINT     5
-  #define AUDIO_RX_SIZE         180
   #define AUDIO_SYNC_ENDPOINT	6
   #define ENDPOINT2_CONFIG	ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
   #define ENDPOINT3_CONFIG	ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK
@@ -843,9 +840,7 @@ let me know?  http://forum.pjrc.com/forums/4-Suggestions-amp-Bug-Reports
   #define MIDI_RX_SIZE_480      512
   #define AUDIO_INTERFACE	3	// Audio (uses 3 consecutive interfaces)
   #define AUDIO_TX_ENDPOINT     5
-  #define AUDIO_TX_SIZE         180
   #define AUDIO_RX_ENDPOINT     5
-  #define AUDIO_RX_SIZE         180
   #define AUDIO_SYNC_ENDPOINT	6
   #define ENDPOINT2_CONFIG	ENDPOINT_RECEIVE_UNUSED + ENDPOINT_TRANSMIT_INTERRUPT
   #define ENDPOINT3_CONFIG	ENDPOINT_RECEIVE_BULK + ENDPOINT_TRANSMIT_BULK
@@ -925,9 +920,7 @@ let me know?  http://forum.pjrc.com/forums/4-Suggestions-amp-Bug-Reports
   #define KEYMEDIA_INTERVAL     4
   #define AUDIO_INTERFACE	9	// Audio (uses 3 consecutive interfaces)
   #define AUDIO_TX_ENDPOINT     13
-  #define AUDIO_TX_SIZE         180
   #define AUDIO_RX_ENDPOINT     13
-  #define AUDIO_RX_SIZE         180
   #define AUDIO_SYNC_ENDPOINT	14
   #define MULTITOUCH_INTERFACE  12	// Touchscreen
   #define MULTITOUCH_ENDPOINT   15
